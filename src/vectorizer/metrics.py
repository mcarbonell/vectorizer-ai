[{"logger.info(f": "SIM: {ssim:.4f"}, {"image2_path}": "TODO: Implementar con CLIP\n        # Por ahora retornar un placeholder\n        logger.warning(", "placeholder": "return 0.4\n\n    def calculate_quality_score(\n        self", "comparison_result": "ComparisonResult\n    ) -> float:", "Calcula una puntuaci\u00f3n de calidad global.\n\n        Args:\n            comparison_result: Resultado de la comparaci\u00f3n.\n\n        Returns:\n            Puntuaci\u00f3n de calidad entre 0 y 1.\n        \"": "ssim = comparison_result.ssim\n        clip_similarity = comparison_result.clip_similarity\n\n        quality = self._calculate_quality_score(ssim", "logger.info(f": "uality score: {quality:.4f"}, ["np.ndarray, np.ndarray]:\n        \"", "Redimensiona dos im\u00e1genes para que tengan el mismo tama\u00f1o.\n\n        Args:\n            img1: Primera imagen.\n            img2: Segunda imagen.\n\n        Returns:\n            Tupla con las im\u00e1genes redimensionadas.\n        \"", "\n        h1, w1 = img1.shape[:2]\n        h2, w2 = img2.shape[:2]\n\n        # Usar el tama\u00f1o m\u00e1s peque\u00f1o\n        target_h = min(h1, h2)\n        target_w = min(w1, w2)\n\n        if h1 != target_h or w1 != target_w:\n            img1 = self._resize_image(img1, target_w, target_h)\n\n        if h2 != target_h or w2 != target_w:\n            img2 = self._resize_image(img2, target_w, target_h)\n\n        return img1, img2\n\n    def _resize_image(\n        self, img: np.ndarray, width: int, height: int\n    ) -> np.ndarray:\n        \"", "Redimensiona una imagen.\n\n        Args:\n            img: Imagen a redimensionar.\n            width: Ancho deseado.\n            height: Alto deseado.\n\n        Returns:\n            Imagen redimensionada.\n        \"", "\n        pil_img = Image.fromarray(img)\n        resized = pil_img.resize((width, height), Image.LANCZOS)\n        return np.array(resized)\n\n    def _calculate_ssim(self, img1: np.ndarray, img2: np.ndarray) -> float:\n        \"", "Calcula el \u00edndice de similitud estructural (SSIM).\n\n        Args:\n            img1: Primera imagen.\n            img2: Segunda imagen.\n\n        Returns:\n            Valor SSIM entre 0 y 1.\n        \"", "\n        from skimage.metrics import structural_similarity as ssim\n\n        # Convertir a escala de grises\n        gray1 = np.dot(img1[..., :3], [0.2989, 0.5870, 0.1140])\n        gray2 = np.dot(img2[..., :3], [0.2989, 0.5870, 0.1140])\n\n        # Calcular SSIM\n        score = ssim(gray1, gray2, data_range=gray2.max() - gray2.min())\n\n        return float(score)\n\n    def _calculate_quality_score(\n        self, ssim: float, clip_similarity: float\n    ) -> float:\n        \"", "Calcula una puntuaci\u00f3n de calidad global.\n\n        Args:\n            ssim: Valor SSIM.\n            clip_similarity: Valor de similitud CLIP.\n\n        Returns:\n            Puntuaci\u00f3n de calidad entre 0 y 1.\n        \"", "\n        # Ponderar SSIM y CLIP\n        # SSIM es m\u00e1s importante para similitud estructural\n        # CLIP es m\u00e1s importante para similitud sem\u00e1ntica\n        weight_ssim = 0.6\n        weight_clip = 0.4\n\n        quality = (ssim * weight_ssim) + (clip_similarity * weight_clip)\n\n        return min(max(quality, 0.0), 1.0)"]]